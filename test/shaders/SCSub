Import('env')
import os

extensions = {
    "vert":"GL_VERTEX_SHADER",
    "frag":"GL_FRAGMENT_SHADER",
    "geom":"GL_GEOMETRY_SHADER",
    "comp":"GL_COMPUTE_SHADER",
    "tesc":"GL_TESS_CONTROL_SHADER",
    "tese":"GL_TESS_EVALUATION_SHADER",
}

def shader_builder(target, source, env):
    # target should be singular, source should be multiple
    target = target[0]
    header_contents = """\
// SCONS GENERATED HEADER
// DO NOT MODIFY
#ifndef TEST_SHADER_{shader_name}
#define TEST_SHADER_{shader_name}

#include <glad/glad.h>
#include <GLFW/glfw3.h>

namespace programs
{{
    class {shader_name}
    {{
        static GLuint program_id;
        static bool compiled;
        static bool error;
        static char *err_message;
        public:
        static GLuint get_program();
        static bool had_error() {{return error;}}
        static const char *get_error_message() {{return err_message;}}
    }};

    GLuint {shader_name}::program_id = 0;
    bool {shader_name}::compiled = false;
    bool {shader_name}::error = false;
    static char ermsg[256];
    char* {shader_name}::err_message = ermsg;

    GLuint {shader_name}::get_program()
    {{
        if(!compiled)
        {{
            program_id = glCreateProgram();
            GLint comp_status;
            {shader_compiles}
            glLinkProgram(program_id);
            glGetProgramiv(program_id, GL_LINK_STATUS, &comp_status);
            if(comp_status != GL_TRUE)
            {{
                error = true;
                glGetProgramInfoLog(program_id, 256, NULL, reinterpret_cast<GLchar *>(err_message));
                return 0;
            }}
            compiled = true;
        }}
        return program_id;
    }}
}}
#endif // TEST_SHADER_{shader_name}
"""

    header_shader_comp = """
            const char *{ext}_src = "{source}";
            GLuint {ext}_id = glCreateShader({shader_type});
            glShaderSource({ext}_id, 1, &{ext}_src, NULL);
            glCompileShader({ext}_id);
            glGetShaderiv({ext}_id, GL_COMPILE_STATUS, &comp_status);
            if(comp_status != GL_TRUE)
            {{
                error = true;
                glGetShaderInfoLog({ext}_id, 256, NULL, reinterpret_cast<GLchar *>(err_message));
                return 0;
            }}
            glAttachShader(program_id, {ext}_id);
"""

    shader_name = os.path.basename(target.abspath).split('.')[0]
    shader_compiles = ""
    for shader in source:
        ext = os.path.basename(shader.abspath).split('.')[1]
        contents = shader.get_text_contents().replace('\r', '').replace('\n', '\\n')
        shader_type = extensions[ext]
        shader_compiles += header_shader_comp.format(ext = ext, source = contents, shader_type = shader_type)
    header = open(target.abspath, "w+")
    header.write(header_contents.format(shader_name=shader_name, shader_compiles=shader_compiles))
    header.close()


    

# Step one: Find all similarly named shaders and setup a shader dictionary
shaders = {}
# Shader dict format
# <key>: the shader name, the file name without path or extension
# target_path: target file path
# sources: dictionary of file entries as { <extension>:<path> }

for ext in extensions.keys():
    for shader in Glob("*.{}".format(ext)):
        shader_name = os.path.basename(shader.abspath).split('.')[0]
        # We already have the extension as ext
        if not shader_name in shaders.keys():
            shaders[shader_name] = {
                "target_path" : str(os.path.dirname(shader.abspath) + "/gen/" + shader_name + ".h"),
                "sources": {}
            }
        
        if ext in shaders[shader_name]["sources"].keys(): # I don't think this is possible?
            print("ERROR: Shader {} has multiple files for the same extension. ({})".format(shader_name, ext))
            Exit(1)
        
        shaders[shader_name]["sources"][ext] = shader.abspath
            

# Shader table is set up
# Step two: Set up shader builder
bld = Builder(
    action = shader_builder,
    suffix = ".h", 
    src_suffix=extensions.keys()
)
env.Append(BUILDERS={"Shader":bld})

# Step three: Shaders with same names become linked programs. Write headers
shader_bld = []

for shader_name in shaders.keys():
    shader_bld += env.Shader(shaders[shader_name]["target_path"], shaders[shader_name]["sources"].values())

Return('shader_bld')